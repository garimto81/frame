<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포커스 이슈 탐지기 (GitHub 연동)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-item:hover { background-color: #f0f9ff; }
        .result-item.selected { background-color: #dbeafe; border-left-width: 4px; border-color: #3b82f6; }
        #chart-tooltip {
            position: absolute;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            color: black;
            border-radius: 0.75rem;
            padding: 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            transform: translate(-50%, -50%);
            z-index: 50;
            width: 40rem; /* Increased size */
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen flex flex-col">

    <header class="text-center py-4 border-b bg-white shadow-sm flex-shrink-0">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-900">포커스 이슈 탐지기 (GitHub 연동)</h1>
        <p id="model-status" class="text-sm text-yellow-600 mt-1">인식 모델 로딩 중...</p>
    </header>
    
    <main class="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-4 p-4 overflow-hidden">
        <!-- Left Panel: Controls & Results List -->
        <div class="lg:col-span-1 flex flex-col gap-4 overflow-hidden">
            <div class="bg-white p-6 rounded-2xl shadow-lg flex-shrink-0">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">1. 제어 패널</h2>
                <div class="space-y-4">
                    <div>
                        <label for="video-files-input" class="block text-sm font-medium text-gray-700 mb-1">영상 파일 선택</label>
                        <input type="file" id="video-files-input" multiple accept="video/mp4,video/quicktime,.mov" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
                    </div>
                     <div>
                        <label for="threshold-slider" class="block text-sm font-medium text-gray-700">흐림 기준값</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="threshold-slider" min="0" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span id="threshold-value" class="font-bold text-lg text-blue-600 w-12 text-center">50</span>
                        </div>
                    </div>
                     <button id="analyze-button" class="w-full bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        분석 및 GitHub에 저장
                    </button>
                    <div id="loading-indicator" class="hidden flex flex-col items-center"><div class="loader"></div><p id="progress-text" class="text-gray-600 mt-2"></p></div>
                </div>
            </div>
            <div class="bg-white p-6 rounded-2xl shadow-lg flex-grow flex flex-col overflow-hidden">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">2. 분석 기록</h2>
                <div id="results-list-container" class="flex-grow overflow-y-auto -mr-2 pr-2">
                    <p id="results-list-placeholder" class="text-gray-500 text-center py-4">GitHub 정보 확인 중...</p>
                </div>
                <div id="pagination-controls" class="pt-4 border-t flex justify-center gap-2"></div>
            </div>
        </div>

        <!-- Right Panel: Details -->
        <div id="right-panel" class="lg:col-span-2 flex flex-col gap-4 overflow-hidden">
             <div class="bg-white p-6 rounded-2xl shadow-lg flex-grow flex flex-col overflow-hidden">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">3. 상세 분석</h2>
                <div id="details-container" class="relative flex-grow min-h-0">
                    <p id="chart-placeholder" class="text-gray-500 text-center absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">왼쪽 목록에서 분석 기록을 선택하세요.</p>
                    <canvas id="detail-chart"></canvas>
                </div>
            </div>
        </div>
    </main>

    <!-- Chart Tooltip -->
    <div id="chart-tooltip" class="hidden"></div>
    <script>
        // --- DOM References ---
        const videoFilesInput = document.getElementById('video-files-input');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdValueEl = document.getElementById('threshold-value');
        const analyzeButton = document.getElementById('analyze-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const progressText = document.getElementById('progress-text');
        const modelStatus = document.getElementById('model-status');
        const resultsListContainer = document.getElementById('results-list-container');
        const resultsListPlaceholder = document.getElementById('results-list-placeholder');
        const paginationControls = document.getElementById('pagination-controls');
        const chartPlaceholder = document.getElementById('chart-placeholder');
        const detailChartCanvas = document.getElementById('detail-chart');
        const chartTooltip = document.getElementById('chart-tooltip');

        // --- Global State ---
        let videoFiles = [];
        let modelsLoaded = false;
        const MODEL_URL = 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights';
        let allAnalysisData = [];
        let detailChart = null;
        let currentPage = 1;
        const ITEMS_PER_PAGE = 20;

        // --- GitHub API State ---
        const GITHUB_CONFIG = {
            owner: 'garimto81', repo: 'frame', token: '#{GITHUB_TOKEN_PLACEHOLDER}#',
            resultsIndexFile: 'data/results.json'
        };
        const GITHUB_API_URL = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/`;
        const GITHUB_HEADERS = { 'Authorization': `token ${GITHUB_CONFIG.token}`, 'Accept': 'application/vnd.github.v3+json' };
        
        // --- Initialization ---
        async function initializeApp() {
            if (GITHUB_CONFIG.token.includes('PLACEHOLDER')) {
                 modelStatus.textContent = '오류: GitHub Actions를 통해 배포된 페이지에서 접속해야 합니다.';
                 analyzeButton.disabled = true; return;
            }
            await loadFaceApiModels();
        }
        
        async function loadFaceApiModels() {
            try {
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                modelsLoaded = true;
                modelStatus.textContent = '얼굴 인식 모델 로딩 완료!';
                updateAnalyzeButtonState();
                initializeAndLoadGitHubData();
            } catch (error) { modelStatus.textContent = '모델 로딩 실패'; console.error(error); }
        }
        
        // --- GitHub API Functions ---
        async function getFileFromGitHub(path) {
            try {
                const response = await fetch(GITHUB_API_URL + path, { headers: GITHUB_HEADERS });
                if (response.status === 404) return null;
                if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
                return await response.json();
            } catch (error) { console.error(`GitHub 읽기 오류: ${path}`, error); return 'error'; }
        }

        async function updateFileOnGitHub(path, content, sha, commitMessage) {
            const body = { message: commitMessage, content: btoa(unescape(encodeURIComponent(content))), sha: sha };
            try {
                const response = await fetch(GITHUB_API_URL + path, { method: 'PUT', headers: GITHUB_HEADERS, body: JSON.stringify(body) });
                if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
            } catch (error) { console.error(`GitHub 업데이트 오류: ${path}`, error); }
        }

        async function uploadFileToGitHub(path, content, isBinary = false) {
             const body = { message: `Upload ${path}`, content: isBinary ? content.split(',')[1] : btoa(unescape(encodeURIComponent(content))) };
             try {
                const response = await fetch(GITHUB_API_URL + path, { method: 'PUT', headers: GITHUB_HEADERS, body: JSON.stringify(body) });
                if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
                 const result = await response.json();
                 return result.content.download_url;
            } catch (error) { console.error(`GitHub 업로드 오류: ${path}`, error); return null; }
        }
        
        async function initializeAndLoadGitHubData() {
            resultsListPlaceholder.textContent = 'GitHub에서 분석 기록을 확인합니다...';
            let resultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
            if (resultsFile === 'error') { resultsListPlaceholder.textContent = 'GitHub 저장소 접근 실패.'; return; }
            if (resultsFile === null) {
                await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, '[]', null, 'Initialize results.json');
                resultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
            }
            if(resultsFile && resultsFile.content) {
                const content = decodeURIComponent(escape(atob(resultsFile.content)));
                allAnalysisData = JSON.parse(content).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                renderAnalysisResultsList();
            } else { resultsListPlaceholder.textContent = '저장된 분석 기록이 없습니다.'; }
        }

        // --- Core Logic & UI ---
        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData; if (width === 0 || height === 0) return 0; const gray = new Uint8Array(width * height); for (let i = 0; i < data.length; i += 4) { gray[i / 4] = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]; } let laplacianMean = 0; const laplacianValues = []; for (let y = 1; y < height - 1; y++) { for (let x = 1; x < width - 1; x++) { const i = y * width + x; const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i]; laplacianValues.push(laplacian); laplacianMean += laplacian; } } if (laplacianValues.length === 0) return 0; laplacianMean /= laplacianValues.length; return laplacianValues.reduce((acc, val) => acc + Math.pow(val - laplacianMean, 2), 0) / laplacianValues.length;
        }

        function getCentermostFace(detections, videoWidth, videoHeight) {
            if (!detections || detections.length === 0) return null; if (detections.length === 1) return detections[0]; const frameCenterX = videoWidth / 2, frameCenterY = videoHeight / 2; let centermostFace = null, minDistance = Infinity; for (const detection of detections) { const faceCenterX = detection.box.x + detection.box.width / 2; const faceCenterY = detection.box.y + detection.box.height / 2; const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2)); if (distance < minDistance) { minDistance = distance; centermostFace = detection; } } return centermostFace;
        }

        function updateAnalyzeButtonState() { analyzeButton.disabled = videoFiles.length === 0 || !modelsLoaded; }
        
        const externalTooltipHandler = (context) => {
            const {chart, tooltip} = context;
            if (tooltip.opacity === 0) { chartTooltip.style.opacity = 0; chartTooltip.classList.add('hidden'); return; }
            
            const analysisId = chart.canvas.dataset.analysisId;
            const analysisData = allAnalysisData.find(d => d.analysisId === analysisId);
            const dataPoint = tooltip.dataPoints[0];
            const keyFrameData = analysisData.keyFrames.find(kf => kf.time === dataPoint.parsed.x);

            if (keyFrameData) {
                const isOverridden = keyFrameData.manualOverride === 'ok';
                chartTooltip.innerHTML = `<div class="flex gap-4 p-1"><div class="text-center w-1/2"><p class="text-sm font-semibold text-green-400 mb-1">선명</p><img src="${keyFrameData.sharpUrl}" class="w-full h-auto object-contain rounded"></div><div class="text-center w-1/2"><p class="text-sm font-semibold ${isOverridden ? 'text-green-400' : 'text-red-400'} mb-1">${isOverridden ? '흐림 (수동OK)' : '흐림'}</p><img src="${keyFrameData.blurryUrl}" class="w-full h-auto object-contain rounded"></div></div>
                <button id="manual-override-button" data-analysis-id="${analysisId}" data-time="${keyFrameData.time}" class="w-full mt-4 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm">이 프레임은 문제 없음 (녹색으로 변경)</button>`;
                
                chartTooltip.style.opacity = 1;
                chartTooltip.classList.remove('hidden');
                
                const { offsetLeft, offsetTop } = chart.canvas.parentElement;
                chartTooltip.style.left = offsetLeft + tooltip.caretX + 'px';
                chartTooltip.style.top = offsetTop + tooltip.caretY + 'px';
                
                const overrideButton = document.getElementById('manual-override-button');
                if (overrideButton) {
                    overrideButton.onclick = (e) => {
                        e.stopPropagation();
                        handleManualCorrection(analysisId, keyFrameData.time);
                    };
                }
            } else { chartTooltip.style.opacity = 0; chartTooltip.classList.add('hidden'); }
        };

        // --- Render Functions ---
        function renderAnalysisResultsList() {
            resultsListPlaceholder.classList.add('hidden');
            resultsListContainer.innerHTML = '';
            
            const totalPages = Math.ceil(allAnalysisData.length / ITEMS_PER_PAGE);
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            const endIndex = startIndex + ITEMS_PER_PAGE;
            const paginatedData = allAnalysisData.slice(startIndex, endIndex);

            paginatedData.forEach((data) => {
                const item = document.createElement('div');
                item.className = 'result-item p-3 border-b flex justify-between items-center cursor-pointer';
                item.dataset.analysisId = data.analysisId;
                item.innerHTML = `<div class="flex-grow"><p class="font-medium text-gray-800 truncate text-sm">${data.fileName}</p><p class="text-xs text-gray-500">${new Date(data.timestamp).toLocaleDateString()}</p></div><div class="text-sm font-semibold ${data.problematic ? 'text-red-500' : 'text-green-600'}">Avg: ${data.avgScore.toFixed(2)}</div>`;
                resultsListContainer.appendChild(item);
            });

            resultsListContainer.querySelectorAll('.result-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    resultsListContainer.querySelectorAll('.result-item').forEach(r => r.classList.remove('selected'));
                    item.classList.add('selected');
                    const analysisId = e.currentTarget.dataset.analysisId;
                    renderDetailedView(analysisId);
                });
            });
            renderPagination(totalPages);
        }
        
        function renderPagination(totalPages) {
            paginationControls.innerHTML = '';
            if (totalPages <= 1) return;
            for (let i = 1; i <= totalPages; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.className = `px-3 py-1 rounded-md text-sm ${i === currentPage ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`;
                button.onclick = () => { currentPage = i; renderAnalysisResultsList(); };
                paginationControls.appendChild(button);
            }
        }

        function renderDetailedView(analysisId) {
            chartPlaceholder.classList.add('hidden');
            const resultData = allAnalysisData.find(d => d.analysisId === analysisId);
            if (!resultData) return;

            if (detailChart) { detailChart.destroy(); }
            detailChartCanvas.dataset.analysisId = analysisId;
            
            const blurryPoints = (resultData.keyFrames || []).filter(kf => kf.manualOverride !== 'ok').map(kf => ({x: kf.time, y: resultData.frameScores.find(fs => fs.time === kf.time)?.score || 0}));
            const okPoints = (resultData.keyFrames || []).filter(kf => kf.manualOverride === 'ok').map(kf => ({x: kf.time, y: resultData.frameScores.find(fs => fs.time === kf.time)?.score || 0}));

            detailChart = new Chart(detailChartCanvas, {
                type: 'line',
                data: {
                    datasets: [
                        { label: '선명도', data: resultData.frameScores.map(fs => ({x: fs.time, y: fs.score})), borderColor: 'rgba(59, 130, 246, 0.5)', borderWidth: 1, pointRadius: 0, tension: 0.4, },
                        { label: '흐림 감지', data: blurryPoints, backgroundColor: 'rgb(239, 68, 68)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter', },
                        { label: '수동 확인', data: okPoints, backgroundColor: 'rgb(34, 197, 94)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter', }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, interaction: { intersect: false, mode: 'index' },
                    plugins: { legend: { display: false }, tooltip: { enabled: false, external: externalTooltipHandler, position: 'nearest' } },
                    scales: { x: { type: 'linear', title: { display: true, text: '시간 (초)' } }, y: { beginAtZero: true, title: { display: true, text: '점수' } } }
                }
            });
        }
        
        async function handleManualCorrection(analysisId, time) {
            const analysisIndex = allAnalysisData.findIndex(d => d.analysisId === analysisId);
            if (analysisIndex === -1) return;
            const keyFrameIndex = allAnalysisData[analysisIndex].keyFrames.findIndex(kf => kf.time === time);
            if (keyFrameIndex === -1) return;

            allAnalysisData[analysisIndex].keyFrames[keyFrameIndex].manualOverride = 'ok';
            renderDetailedView(analysisId); // Re-render chart immediately

            const existingResultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
            await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, JSON.stringify(allAnalysisData, null, 2), existingResultsFile.sha, `Update manual override for ${analysisId}`);
        }

        // --- Event Handlers & Main Analysis Logic ---
        videoFilesInput.addEventListener('change', (event) => { videoFiles = Array.from(event.target.files); updateAnalyzeButtonState(); });
        thresholdSlider.addEventListener('input', (event) => { thresholdValueEl.textContent = event.target.value; });

        analyzeButton.addEventListener('click', async () => { /* ... */
            if (videoFiles.length === 0) { alert('먼저 분석할 영상 파일을 선택해주세요.'); return; }
            loadingIndicator.style.display = 'flex';
            analyzeButton.disabled = true;
            document.getElementById('log-container').innerHTML = ''; // Clear live log
            
            const threshold = parseFloat(thresholdSlider.value);
            const analysisVideo = document.createElement('video');
            analysisVideo.crossOrigin = 'anonymous';
            const analysisCanvas = document.createElement('canvas');
            const analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });
            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            analysisVideo.muted = true;
            analysisVideo.preload = 'metadata';

            for (let i = 0; i < videoFiles.length; i++) {
                const file = videoFiles[i];
                const cleanFileNameForId = file.name.replace(/[^a-zA-Z0-9]/g, '_');
                const analysisId = `${cleanFileNameForId}_${new Date().toISOString()}`;
                
                const fileURL = URL.createObjectURL(file);
                analysisVideo.src = fileURL;

                const duration = await new Promise(resolve => { analysisVideo.onloadedmetadata = () => resolve(analysisVideo.duration); });
                
                const frameScores = [];
                let previousFrame = null;
                const keyFramesToUpload = [];
                const SAMPLING_INTERVAL_SECONDS = 0.5;
                const totalSamples = Math.floor(duration / SAMPLING_INTERVAL_SECONDS);
                
                for (let j = 0; j < totalSamples; j++) {
                    const currentTime = j * SAMPLING_INTERVAL_SECONDS;
                    progressText.textContent = `분석 중... (${i + 1}/${videoFiles.length}) - ${file.name} (샘플 ${j + 1}/${totalSamples})`;
                    await new Promise(resolve => { analysisVideo.onseeked = () => resolve(); analysisVideo.currentTime = currentTime; });
                    
                    const detections = await faceapi.detectAllFaces(analysisVideo, new faceapi.TinyFaceDetectorOptions());
                    const centermostFace = getCentermostFace(detections, analysisVideo.videoWidth, analysisVideo.videoHeight);
                    
                    if (centermostFace) {
                        analysisCanvas.width = analysisVideo.videoWidth; analysisCanvas.height = analysisVideo.videoHeight;
                        analysisCtx.drawImage(analysisVideo, 0, 0, analysisCanvas.width, analysisCanvas.height);
                        
                        const { x, y, width, height } = centermostFace.box;
                        const faceImageData = analysisCtx.getImageData(x, y, width, height);
                        const score = calculateFocusScore(faceImageData);
                        const isBlurry = score < threshold;
                        
                        cropCanvas.width = width; cropCanvas.height = height;
                        cropCtx.putImageData(faceImageData, 0, 0);
                        const dataURL = cropCanvas.toDataURL('image/jpeg', 0.8);

                        const currentFrame = { time: currentTime, score: score, isBlurry: isBlurry, dataURL: dataURL };
                        frameScores.push(currentFrame);

                        if (previousFrame && !previousFrame.isBlurry && currentFrame.isBlurry) {
                            keyFramesToUpload.push({ time: currentFrame.time, sharpDataURL: previousFrame.dataURL, blurryDataURL: currentFrame.dataURL });
                        }
                        previousFrame = currentFrame;
                    } else { previousFrame = null; }
                }
                
                const detectedFrameCount = frameScores.length;
                const totalScore = frameScores.reduce((sum, frame) => sum + frame.score, 0);
                const blurryFrameCount = frameScores.filter(f => f.isBlurry).length;
                const blurryPercentage = detectedFrameCount > 0 ? (blurryFrameCount / detectedFrameCount) * 100 : 0;
                
                const uploadedKeyFrames = [];
                for(const kf of keyFramesToUpload) {
                    const cleanFileName = file.name.split('.').slice(0, -1).join('');
                    const sharpFileName = `${cleanFileName}_${kf.time.toFixed(2)}s_sharp.jpeg`;
                    const blurryFileName = `${cleanFileName}_${kf.time.toFixed(2)}s_blurry.jpeg`;
                    const sharpUrl = await uploadFileToGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/${sharpFileName}`, kf.sharpDataURL, true);
                    const blurryUrl = await uploadFileToGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/${blurryFileName}`, kf.blurryDataURL, true);
                    if (sharpUrl && blurryUrl) { uploadedKeyFrames.push({time: kf.time, sharpUrl, blurryUrl}); }
                }
                
                const newResult = {
                    analysisId: analysisId, timestamp: new Date().toISOString(), fileName: file.name,
                    avgScore: detectedFrameCount > 0 ? totalScore / detectedFrameCount : 0,
                    problematic: blurryPercentage > 10, blurryPercentage: blurryPercentage,
                    frameScores: frameScores.map(d => ({time: d.time, score: d.score})), keyFrames: uploadedKeyFrames
                };

                const existingResultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
                let allResults = []; let currentSha = null;
                if (existingResultsFile && existingResultsFile.content) {
                    allResults = JSON.parse(decodeURIComponent(escape(atob(existingResultsFile.content))));
                    currentSha = existingResultsFile.sha;
                }
                allResults.push(newResult);
                
                await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, JSON.stringify(allResults, null, 2), currentSha, `Add analysis result for ${file.name}`);
                URL.revokeObjectURL(fileURL);
            }

            loadingIndicator.style.display = 'none';
            analyzeButton.disabled = false;
            videoFiles = []; 
            updateAnalyzeButtonState();
            await initializeAndLoadGitHubData();
        });

        window.onload = initializeApp;

    </script>
</body>
</html>
