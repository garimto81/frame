<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포커스 이슈 탐지기 (GitHub 연동)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <!-- Face Recognition Library -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-card:hover { background-color: #f9fafb; }
        /* Custom Tooltip for Chart */
        #chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s ease;
            transform: translate(-50%, -110%);
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">포커스 이슈 탐지기 (GitHub 연동)</h1>
            <p id="model-status" class="text-lg text-yellow-600 mt-2">인식 모델 로딩 중...</p>
        </header>
        
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b pb-2">1. 영상 파일 선택</h2>
            <p class="text-gray-600 mb-4">분석할 영상 클립(.mov, .mp4 등)을 선택해주세요.</p>
            <input type="file" id="video-files-input" multiple accept="video/mp4,video/quicktime,.mov" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
        </div>

        <div class="bg-white p-6 rounded-2xl shadow-lg text-center mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b pb-2">2. 분석 실행</h2>
            <div class="max-w-md mx-auto mb-6">
                 <label for="threshold-slider" class="block mb-2 font-medium">흐림 기준값 (Threshold)</label>
                <div class="flex items-center gap-4">
                    <input type="range" id="threshold-slider" min="0" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="threshold-value" class="font-bold text-lg text-blue-600 w-12 text-center">50</span>
                </div>
            </div>
            <button id="analyze-button" class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                분석 및 GitHub에 저장
            </button>
             <div id="loading-indicator" class="hidden mt-4 flex flex-col items-center"><div class="loader"></div><p id="progress-text" class="text-gray-600 mt-2"></p></div>
        </div>
        
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-8">
             <h2 class="text-xl font-semibold mb-4 border-b pb-2">3. 과거 분석 결과 (GitHub)</h2>
             <p class="text-gray-600 mb-2">과거 분석 기록입니다. 그래프 위 빨간 점에 마우스를 올리면 주요 프레임을 확인할 수 있습니다.</p>
            <div id="results-list-container" class="space-y-4"><p id="results-list-placeholder" class="text-gray-500 text-center py-4">GitHub 정보 확인 중...</p></div>
        </div>

         <div class="bg-white p-6 rounded-2xl shadow-lg mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b pb-2">4. 분석 로그</h2>
            <p class="text-gray-600 mb-2">실시간 분석 로그 또는 선택한 과거 분석의 로그가 표시됩니다.</p>
            <div id="log-container" class="h-96 overflow-y-auto bg-gray-900 text-white font-mono rounded-lg p-4 border text-sm"><p class="text-gray-400 text-center py-4">분석을 시작하거나 과거 기록을 선택하세요.</p></div>
        </div>
    </div>

    <!-- Chart Tooltip -->
    <div id="chart-tooltip" class="rounded-lg shadow-xl hidden"></div>

    <script>
        // --- DOM Element References ---
        const videoFilesInput = document.getElementById('video-files-input');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdValueEl = document.getElementById('threshold-value');
        const analyzeButton = document.getElementById('analyze-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const progressText = document.getElementById('progress-text');
        const modelStatus = document.getElementById('model-status');
        const logContainer = document.getElementById('log-container');
        const resultsListContainer = document.getElementById('results-list-container');
        const resultsListPlaceholder = document.getElementById('results-list-placeholder');
        const chartTooltip = document.getElementById('chart-tooltip');

        // --- Global State ---
        let videoFiles = [];
        let modelsLoaded = false;
        const MODEL_URL = 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights';
        let allAnalysisData = [];

        // --- GitHub API State ---
        const GITHUB_CONFIG = {
            owner: 'garimto81',
            repo: 'frame',
            token: '#{GITHUB_TOKEN_PLACEHOLDER}#',
            resultsIndexFile: 'data/results.json',
            assetsPath: 'data/assets'
        };

        const GITHUB_API_URL = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/`;
        const GITHUB_HEADERS = {
            'Authorization': `token ${GITHUB_CONFIG.token}`,
            'Accept': 'application/vnd.github.v3+json',
        };
        
        // --- Initialization ---
        async function initializeApp() {
             if (GITHUB_CONFIG.token.includes('PLACEHOLDER')) {
                 modelStatus.textContent = '오류: GitHub Actions를 통해 배포된 페이지에서 접속해야 합니다.';
                 analyzeButton.disabled = true;
                 return;
            }
            await loadFaceApiModels();
        }
        
        async function loadFaceApiModels() {
             try {
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                modelsLoaded = true;
                modelStatus.textContent = '얼굴 인식 모델 로딩 완료! 분석할 영상을 선택하세요.';
                updateAnalyzeButtonState();
                initializeAndLoadGitHubData();
            } catch (error) {
                modelStatus.textContent = '얼굴 인식 모델 로딩 실패. 새로고침 해주세요.';
                console.error("Face-api model loading failed:", error);
            }
        }
        
        // --- GitHub API Functions ---
        async function getFileFromGitHub(path) {
            try {
                const response = await fetch(GITHUB_API_URL + path, { headers: GITHUB_HEADERS });
                if (response.status === 404) return null;
                if (!response.ok) throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                return await response.json();
            } catch (error) {
                console.error('GitHub 파일 읽기 오류:', error);
                appendLog(`[ERROR] GitHub 파일 읽기 실패: ${path}.`, 'text-red-500');
                return 'error';
            }
        }

        async function updateFileOnGitHub(path, content, sha, commitMessage) {
            const body = { message: commitMessage, content: btoa(unescape(encodeURIComponent(content))), sha: sha };
            try {
                const response = await fetch(GITHUB_API_URL + path, { method: 'PUT', headers: GITHUB_HEADERS, body: JSON.stringify(body) });
                if (!response.ok) throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                appendLog(`[INFO] '${path}' 파일 업데이트/생성 완료`, 'text-blue-400');
            } catch (error) { console.error('GitHub 파일 업데이트 오류:', error); appendLog(`[ERROR] GitHub 파일 업데이트 실패: ${path}.`, 'text-red-500'); }
        }

        async function uploadImageToGitHub(path, content, commitMessage) {
             const body = { message: commitMessage, content: content.split(',')[1] };
             try {
                const response = await fetch(GITHUB_API_URL + path, { method: 'PUT', headers: GITHUB_HEADERS, body: JSON.stringify(body) });
                 if (!response.ok) throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                 const result = await response.json();
                 return result.content.download_url;
            } catch (error) {
                console.error('GitHub 이미지 업로드 오류:', error);
                appendLog(`[ERROR] GitHub 이미지 업로드 실패: ${path}.`, 'text-red-500');
                return null;
            }
        }
        
        async function initializeAndLoadGitHubData() {
            resultsListPlaceholder.textContent = 'GitHub에서 분석 기록을 확인합니다...';
            let resultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);

            if (resultsFile === 'error') { resultsListPlaceholder.textContent = 'GitHub 저장소 접근에 실패했습니다. 설정을 확인하세요.'; return; }
            if (resultsFile === null) {
                appendLog(`[INFO] '${GITHUB_CONFIG.resultsIndexFile}' 파일을 찾을 수 없습니다. 새로 생성합니다.`, 'text-yellow-400');
                await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, '[]', null, 'Initialize results.json');
                resultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
            }

            const assetsDirKeepPath = `${GITHUB_CONFIG.assetsPath}/.gitkeep`;
            const keepFile = await getFileFromGitHub(assetsDirKeepPath);
            if (keepFile === null) {
                appendLog(`[INFO] 에셋 저장 폴더를 초기화합니다.`, 'text-yellow-400');
                await updateFileOnGitHub(assetsDirKeepPath, '', null, 'Initialize assets directory');
            }

            if(resultsFile && resultsFile.content) {
                const content = decodeURIComponent(escape(atob(resultsFile.content)));
                allAnalysisData = JSON.parse(content).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                renderAnalysisResults();
            } else {
                 resultsListPlaceholder.textContent = '아직 저장된 분석 기록이 없습니다.';
            }
        }

        // --- Core Logic & UI ---
        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData; if (width === 0 || height === 0) return 0; const gray = new Uint8Array(width * height); for (let i = 0; i < data.length; i += 4) { gray[i / 4] = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]; } let laplacianMean = 0; const laplacianValues = []; for (let y = 1; y < height - 1; y++) { for (let x = 1; x < width - 1; x++) { const i = y * width + x; const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i]; laplacianValues.push(laplacian); laplacianMean += laplacian; } } if (laplacianValues.length === 0) return 0; laplacianMean /= laplacianValues.length; return laplacianValues.reduce((acc, val) => acc + Math.pow(val - laplacianMean, 2), 0) / laplacianValues.length;
        }

        function getCentermostFace(detections, videoWidth, videoHeight) {
            if (!detections || detections.length === 0) return null; if (detections.length === 1) return detections[0]; const frameCenterX = videoWidth / 2, frameCenterY = videoHeight / 2; let centermostFace = null, minDistance = Infinity; for (const detection of detections) { const faceCenterX = detection.box.x + detection.box.width / 2; const faceCenterY = detection.box.y + detection.box.height / 2; const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2)); if (distance < minDistance) { minDistance = distance; centermostFace = detection; } } return centermostFace;
        }

        function updateAnalyzeButtonState() { analyzeButton.disabled = videoFiles.length === 0 || !modelsLoaded; }
        
        function appendLog(message, colorClass = 'text-gray-400') {
            const logEntry = document.createElement('div');
            logEntry.textContent = `> ${message}`;
            logEntry.className = colorClass;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        const externalTooltipHandler = (context) => {
            const {chart, tooltip} = context;
            let tooltipEl = chart.canvas.parentNode.querySelector('#chart-tooltip');
            if (tooltip.opacity === 0) {
                tooltipEl.style.opacity = 0;
                return;
            }
            
            const dataPointIndex = tooltip.dataPoints[0].dataIndex;
            const analysisId = chart.canvas.dataset.analysisId;
            const analysisData = allAnalysisData.find(d => d.analysisId === analysisId);
            const keyFrameData = analysisData.keyFrames.find(kf => kf.time === tooltip.dataPoints[0].parsed.x);

            if (keyFrameData) {
                tooltipEl.innerHTML = `<div class="flex gap-2 p-1"><div class="text-center"><p class="text-xs font-semibold text-green-400 mb-1">선명</p><img src="${keyFrameData.sharpUrl}" class="w-24 h-24 object-cover rounded"></div><div class="text-center"><p class="text-xs font-semibold text-red-400 mb-1">흐림</p><img src="${keyFrameData.blurryUrl}" class="w-24 h-24 object-cover rounded"></div></div>`;
                tooltipEl.style.opacity = 1;
                tooltipEl.style.left = tooltip.caretX + 'px';
                tooltipEl.style.top = tooltip.caretY + 'px';
            } else {
                 tooltipEl.style.opacity = 0;
            }
        };

        function renderAnalysisResults() {
            resultsListPlaceholder.classList.add('hidden');
            resultsListContainer.innerHTML = '';
            
            allAnalysisData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'result-card p-4 bg-white rounded-lg shadow-md border';
                card.dataset.analysisId = data.analysisId;
                card.innerHTML = `<div class="flex justify-between items-center text-sm mb-2"><p class="font-medium truncate pr-4">${data.fileName}</p><p class="font-semibold ${data.problematic ? 'text-red-500' : 'text-green-600'}">Avg: ${data.avgScore.toFixed(2)}</p></div><div class="relative h-16"><canvas id="chart-${data.analysisId}"></canvas></div>`;
                resultsListContainer.appendChild(card);
                
                const ctx = document.getElementById(`chart-${data.analysisId}`).getContext('2d');
                ctx.canvas.dataset.analysisId = data.analysisId;

                const blurryPoints = data.keyFrames ? data.keyFrames.map(kf => ({x: kf.time, y: data.frameScores.find(fs => fs.time === kf.time)?.score || 0})) : [];

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: '선명도',
                                data: data.frameScores.map(fs => ({x: fs.time, y: fs.score})),
                                borderColor: 'rgba(59, 130, 246, 0.7)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1,
                            },
                            {
                                label: '흐림 감지',
                                data: blurryPoints,
                                backgroundColor: 'rgb(239, 68, 68)',
                                pointRadius: 5,
                                pointHoverRadius: 7,
                                type: 'scatter',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { intersect: false, mode: 'index' },
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false, external: externalTooltipHandler, position: 'nearest' }
                        },
                        scales: { x: { type: 'linear', title: { display: true, text: '시간 (초)' } }, y: { beginAtZero: true, title: { display: true, text: '점수' } } }
                    }
                });
            });

            resultsListContainer.querySelectorAll('.result-card').forEach(card => {
                card.addEventListener('click', async (e) => {
                    const analysisId = e.currentTarget.dataset.analysisId;
                    const logFile = await getFileFromGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/log.txt`);
                    if (logFile && logFile.content) {
                        const logContent = decodeURIComponent(escape(atob(logFile.content)));
                        logContainer.innerHTML = '';
                        logContent.split('\n').forEach(line => appendLog(line));
                    } else {
                        logContainer.innerHTML = '<p class="text-gray-400 text-center py-4">로그 파일을 찾을 수 없습니다.</p>';
                    }
                });
            });
        }
        
        // --- Event Handlers & Main Analysis Logic ---
        videoFilesInput.addEventListener('change', (event) => { videoFiles = Array.from(event.target.files); updateAnalyzeButtonState(); });
        thresholdSlider.addEventListener('input', (event) => { thresholdValueEl.textContent = event.target.value; });

        analyzeButton.addEventListener('click', async () => { /* ... */
            if (videoFiles.length === 0) { alert('먼저 분석할 영상 파일을 선택해주세요.'); return; }
            loadingIndicator.style.display = 'flex';
            analyzeButton.disabled = true;
            logContainer.innerHTML = ''; // Clear live log
            
            const threshold = parseFloat(thresholdSlider.value);
            const analysisVideo = document.createElement('video');
            analysisVideo.crossOrigin = 'anonymous';
            const analysisCanvas = document.createElement('canvas');
            const analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });
            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            analysisVideo.muted = true;
            analysisVideo.preload = 'metadata';

            for (let i = 0; i < videoFiles.length; i++) {
                const file = videoFiles[i];
                const cleanFileNameForId = file.name.replace(/[^a-zA-Z0-9]/g, '_');
                const analysisId = `${cleanFileNameForId}_${new Date().toISOString()}`;
                let liveLogContent = `[START] '${file.name}' 분석을 시작합니다. (ID: ${analysisId})\n`;
                appendLog(`[START] '${file.name}' 분석 (ID: ${analysisId})`, 'text-cyan-400');
                
                const fileURL = URL.createObjectURL(file);
                analysisVideo.src = fileURL;

                const duration = await new Promise(resolve => { analysisVideo.onloadedmetadata = () => resolve(analysisVideo.duration); });
                
                const frameScores = [];
                let previousFrame = null;
                const keyFramesToUpload = [];
                const SAMPLING_INTERVAL_SECONDS = 0.5;
                const totalSamples = Math.floor(duration / SAMPLING_INTERVAL_SECONDS);
                
                for (let j = 0; j < totalSamples; j++) {
                    const currentTime = j * SAMPLING_INTERVAL_SECONDS;
                    progressText.textContent = `분석 중... (${i + 1}/${videoFiles.length}) - ${file.name} (샘플 ${j + 1}/${totalSamples})`;
                    await new Promise(resolve => { analysisVideo.onseeked = () => resolve(); analysisVideo.currentTime = currentTime; });
                    
                    const detections = await faceapi.detectAllFaces(analysisVideo, new faceapi.TinyFaceDetectorOptions());
                    const centermostFace = getCentermostFace(detections, analysisVideo.videoWidth, analysisVideo.videoHeight);
                    
                    let logLine;
                    if (centermostFace) {
                        analysisCanvas.width = analysisVideo.videoWidth; analysisCanvas.height = analysisVideo.videoHeight;
                        analysisCtx.drawImage(analysisVideo, 0, 0, analysisCanvas.width, analysisCanvas.height);
                        
                        const { x, y, width, height } = centermostFace.box;
                        const faceImageData = analysisCtx.getImageData(x, y, width, height);
                        const score = calculateFocusScore(faceImageData);
                        const isBlurry = score < threshold;

                        logLine = `Time: ${currentTime.toFixed(2)}s | Score: ${score.toFixed(2)} | Status: ${isBlurry ? '흐림' : '선명'}`;
                        appendLog(logLine, isBlurry ? 'text-red-500' : 'text-green-500');
                        
                        cropCanvas.width = width; cropCanvas.height = height;
                        cropCtx.putImageData(faceImageData, 0, 0);
                        const dataURL = cropCanvas.toDataURL('image/jpeg', 0.8);

                        const currentFrame = { time: currentTime, score: score, isBlurry: isBlurry, dataURL: dataURL };
                        frameScores.push(currentFrame);

                        if (previousFrame && !previousFrame.isBlurry && currentFrame.isBlurry) {
                            keyFramesToUpload.push({ time: currentFrame.time, sharpDataURL: previousFrame.dataURL, blurryDataURL: currentFrame.dataURL });
                        }
                        previousFrame = currentFrame;
                    } else {
                        logLine = `Time: ${currentTime.toFixed(2)}s | Status: 얼굴 미검출`;
                        appendLog(logLine, 'text-gray-500');
                        previousFrame = null;
                    }
                    liveLogContent += logLine + '\n';
                }
                
                const detectedFrameCount = frameScores.length;
                const totalScore = frameScores.reduce((sum, frame) => sum + frame.score, 0);
                const blurryFrameCount = frameScores.filter(f => f.isBlurry).length;
                const blurryPercentage = detectedFrameCount > 0 ? (blurryFrameCount / detectedFrameCount) * 100 : 0;
                
                const uploadedKeyFrames = [];
                for(const kf of keyFramesToUpload) {
                    const cleanFileName = file.name.split('.').slice(0, -1).join('');
                    const sharpFileName = `${cleanFileName}_${kf.time.toFixed(2)}s_sharp.jpeg`;
                    const blurryFileName = `${cleanFileName}_${kf.time.toFixed(2)}s_blurry.jpeg`;
                    const sharpUrl = await uploadImageToGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/${sharpFileName}`, kf.sharpDataURL, `upload ${sharpFileName}`);
                    const blurryUrl = await uploadImageToGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/${blurryFileName}`, kf.blurryDataURL, `upload ${blurryFileName}`);
                    if (sharpUrl && blurryUrl) { uploadedKeyFrames.push({time: kf.time, sharpUrl, blurryUrl}); }
                }
                
                await updateFileOnGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/log.txt`, liveLogContent, null, `Add log for ${analysisId}`);
                
                const newResult = {
                    analysisId: analysisId, timestamp: new Date().toISOString(), fileName: file.name,
                    avgScore: detectedFrameCount > 0 ? totalScore / detectedFrameCount : 0,
                    problematic: blurryPercentage > 10, blurryPercentage: blurryPercentage,
                    frameScores: frameScores.map(d => ({time: d.time, score: d.score})), keyFrames: uploadedKeyFrames
                };

                const existingResultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
                let allResults = []; let currentSha = null;
                if (existingResultsFile && existingResultsFile.content) {
                    allResults = JSON.parse(decodeURIComponent(escape(atob(existingResultsFile.content))));
                    currentSha = existingResultsFile.sha;
                }
                allResults.push(newResult);
                
                await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, JSON.stringify(allResults, null, 2), currentSha, `Add analysis result for ${file.name}`);
                
                URL.revokeObjectURL(fileURL);
                appendLog(`[END] '${file.name}' 분석 완료.`, 'text-cyan-400');
            }

            loadingIndicator.style.display = 'none';
            analyzeButton.disabled = false;
            videoFiles = []; 
            updateAnalyzeButtonState();
            await initializeAndLoadGitHubData();
        });

        window.onload = initializeApp;

    </script>
</body>
</html>
