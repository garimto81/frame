<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포커스 이슈 탐지기 (GitHub 연동) - Ver 0.02</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; scroll-behavior: smooth; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-item:hover { background-color: #f0f9ff; }
        .result-item.selected { background-color: #dbeafe; }
        #chart-tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #e5e7eb;
            color: black;
            border-radius: 0.75rem;
            padding: 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 50;
            width: 44rem;
            max-width: 90vw;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }
        progress { -webkit-appearance: none; -moz-appearance: none; appearance: none; height: 8px; border: none; border-radius: 4px; }
        progress::-webkit-progress-bar { background-color: #e5e7eb; border-radius: 4px; }
        progress::-webkit-progress-value { background-color: #3b82f6; border-radius: 4px; transition: width 0.1s linear; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="relative text-center mb-8 py-4">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">포커스 이슈 탐지기 (GitHub 연동)</h1>
            <p id="model-status" class="text-sm text-yellow-600 mt-1">인식 모델 로딩 중...</p>
             <div class="absolute top-4 right-4">
                <button id="how-it-works-button" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-full text-sm font-medium hover:bg-gray-300 transition">작동 방식 보기</button>
            </div>
        </header>
        
        <main class="space-y-8">
            <!-- Hidden video and canvas for processing -->
            <video id="processing-video" class="hidden" muted preload="metadata" crossOrigin="anonymous"></video>
            <canvas id="processing-canvas" class="hidden"></canvas>

            <!-- Controls -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">1. 제어 패널</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                    <div>
                        <label for="video-files-input" class="block text-sm font-medium text-gray-700 mb-1">영상 파일 선택</label>
                        <input type="file" id="video-files-input" multiple accept="video/mp4,video/quicktime,.mov" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"/>
                    </div>
                     <div class="space-y-2">
                        <label for="threshold-slider" class="block text-sm font-medium text-gray-700">흐림 기준값</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="threshold-slider" min="0" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span id="threshold-value" class="font-bold text-lg text-blue-600 w-12 text-center">50</span>
                        </div>
                    </div>
                </div>
                <div class="mt-6 text-center">
                     <button id="analyze-button" class="w-full md:w-auto bg-green-600 text-white font-bold py-3 px-12 rounded-full hover:bg-green-700 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        분석 시작
                    </button>
                    <button id="cancel-button" class="hidden w-full md:w-auto bg-red-600 text-white font-bold py-3 px-12 rounded-full hover:bg-red-700 transition duration-300">
                        분석 중단
                    </button>
                    <div id="loading-indicator" class="hidden mt-4 flex flex-col items-center">
                        <div class="loader"></div>
                        <p id="progress-text" class="text-gray-600 mt-2"></p>
                        <progress id="progress-bar" class="w-full max-w-md mt-2" value="0" max="100"></progress>
                    </div>
                </div>
            </div>

            <!-- Results List -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2">2. 분석 기록</h2>
                 <div id="results-list-container" class="space-y-1">
                    <p id="results-list-placeholder" class="text-gray-500 text-center py-4">GitHub 정보 확인 중...</p>
                </div>
                <div id="pagination-controls" class="pt-4 mt-4 border-t flex justify-center gap-2"></div>
            </div>

            <!-- Details Section (hidden by default) -->
            <div id="details-section" class="hidden space-y-8">
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 id="details-title" class="text-xl font-semibold mb-4 border-b pb-2">3. 상세 분석 그래프</h2>
                    <p class="text-sm text-gray-600 mb-2 -mt-2">그래프 위 빨간 점에 마우스를 올리면 주요 프레임을 확인할 수 있습니다.</p>
                    <div id="chart-container" class="relative h-48">
                        <canvas id="detail-chart"></canvas>
                    </div>
                </div>
                 <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 border-b pb-2">4. 주요 프레임 보기</h2>
                    <div id="key-frames-container" class="space-y-4">
                        <p id="key-frames-placeholder" class="text-gray-500 text-center py-4">이 분석에는 감지된 문제 프레임이 없거나, 아직 기록이 선택되지 않았습니다.</p>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 border-b pb-2">5. 분석 로그</h2>
                    <div id="log-container" class="h-96 overflow-y-auto bg-gray-900 text-white font-mono rounded-lg p-4 border text-sm"><p id="log-placeholder" class="text-gray-400 text-center py-4">분석 기록을 선택하면 로그가 표시됩니다.</p></div>
                </div>
            </div>
        </main>
    </div>

    <!-- How It Works Modal -->
    <div id="how-it-works-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center border-b p-4">
                <h3 class="text-xl font-bold">작동 방식</h3>
                <button id="close-modal-button" class="text-gray-400 hover:text-gray-700 text-3xl leading-none">&times;</button>
            </div>
            <div class="p-6 space-y-4 overflow-y-auto">
                <div>
                    <h4 class="font-bold text-lg mb-2">1. 영상 분석 및 설정</h4>
                    <p class="text-gray-700 text-sm leading-relaxed">
                        사용자는 분석할 영상 파일(.mp4, .mov)을 선택합니다. '흐림 기준값'을 조절하여 선명도 판단의 민감도를 설정할 수 있습니다. (값이 낮을수록 사소한 흐림도 문제로 감지합니다.) '분석 시작'을 누르면 UI 멈춤 없이 백그라운드에서 분석이 진행됩니다.
                    </p>
                </div>
                <div>
                    <h4 class="font-bold text-lg mb-2">2. 얼굴 탐지 및 선명도 측정</h4>
                    <p class="text-gray-700 text-sm leading-relaxed">
                        영상에서 0.5초 간격으로 프레임을 추출하여 <strong>face-api.js</strong>로 얼굴을 탐지합니다. 여러 얼굴이 있다면 영상 중앙에 가장 가까운 얼굴을 기준으로 삼습니다. 탐지된 얼굴 영역에 '라플라시안 분산' 알고리즘을 적용하여 선명도 점수를 계산합니다. 점수가 낮을수록 초점이 흐린 이미지입니다.
                    </p>
                </div>
                <div>
                    <h4 class="font-bold text-lg mb-2">3. 문제 프레임 감지 및 저장</h4>
                    <p class="text-gray-700 text-sm leading-relaxed">
                        선명도 점수가 설정된 기준값보다 낮으면 '흐림'으로 판단합니다. '선명' 상태에서 '흐림'으로 전환되는 시점을 '주요 프레임'으로 감지하고, 직전의 선명한 프레임과 현재의 흐린 프레임을 한 쌍으로 캡처합니다. 분석 완료 후, 모든 결과는 GitHub 저장소에 안전하게 업로드됩니다.
                    </p>
                </div>
                <div>
                    <h4 class="font-bold text-lg mb-2">4. 결과 확인 및 수동 보정</h4>
                    <p class="text-gray-700 text-sm leading-relaxed">
                        분석 기록을 클릭하면 상세 그래프, 주요 프레임, 전체 로그를 확인할 수 있습니다. 그래프의 점 위에 마우스를 올리면 해당 시점의 프레임 이미지를 바로 볼 수 있습니다. 시스템이 '흐림'으로 잘못 판단한 경우, '이 프레임은 문제 없음' 버튼을 눌러 수동으로 상태를 재정의하고 저장할 수 있습니다.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart Tooltip -->
    <div id="chart-tooltip" class="hidden"></div>
    
    <!-- Web Worker Script -->
    <script type="javascript/worker" id="analyzer-worker">
        self.importScripts('https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js');

        const MODEL_URL = 'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights';
        let modelsLoaded = false;
        let offscreenCanvas, offscreenCtx;

        async function loadModels() {
            if (modelsLoaded) return;
            await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
            modelsLoaded = true;
        }

        function calculateFocusScore(imageData) {
            const { width, height, data } = imageData;
            if (width === 0 || height === 0) return 0;
            const gray = new Uint8Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            let laplacianMean = 0;
            const laplacianValues = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = y * width + x;
                    const laplacian = gray[i - width] + gray[i + width] + gray[i - 1] + gray[i + 1] - 4 * gray[i];
                    laplacianValues.push(laplacian);
                    laplacianMean += laplacian;
                }
            }
            if (laplacianValues.length === 0) return 0;
            laplacianMean /= laplacianValues.length;
            return laplacianValues.reduce((acc, val) => acc + Math.pow(val - laplacianMean, 2), 0) / laplacianValues.length;
        }

        function getCentermostFace(detections, videoWidth, videoHeight) {
            if (!detections || detections.length === 0) return null;
            if (detections.length === 1) return detections[0];
            const frameCenterX = videoWidth / 2, frameCenterY = videoHeight / 2;
            let centermostFace = null, minDistance = Infinity;
            for (const detection of detections) {
                const faceCenterX = detection.box.x + detection.box.width / 2;
                const faceCenterY = detection.box.y + detection.box.height / 2;
                const distance = Math.sqrt(Math.pow(frameCenterX - faceCenterX, 2) + Math.pow(frameCenterY - faceCenterY, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    centermostFace = detection;
                }
            }
            return centermostFace;
        }

        self.onmessage = async (event) => {
            const { type, payload } = event.data;

            if (type === 'init') {
                await loadModels();
                self.postMessage({ type: 'worker_ready' });
                return;
            }

            if (type === 'analyze_frame') {
                const { imageBitmap, currentTime, threshold } = payload;
                if (!offscreenCanvas) {
                    offscreenCanvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
                    offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
                }
                offscreenCanvas.width = imageBitmap.width;
                offscreenCanvas.height = imageBitmap.height;
                offscreenCtx.drawImage(imageBitmap, 0, 0);

                const detections = await faceapi.detectAllFaces(offscreenCanvas, new faceapi.TinyFaceDetectorOptions());
                const centermostFace = getCentermostFace(detections, imageBitmap.width, imageBitmap.height);
                
                let result = { time: currentTime };
                if (centermostFace) {
                    const { x, y, width, height } = centermostFace.box;
                    const faceImageData = offscreenCtx.getImageData(x, y, width, height);
                    const score = calculateFocusScore(faceImageData);
                    
                    const cropCanvas = new OffscreenCanvas(width, height);
                    cropCanvas.getContext('2d').putImageData(faceImageData, 0, 0);
                    const dataURL = await cropCanvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 }).then(blob => new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.readAsDataURL(blob);
                    }));

                    result = { ...result, score, dataURL, isBlurry: score < threshold, faceFound: true };
                } else {
                    result = { ...result, score: 0, faceFound: false };
                }
                self.postMessage({ type: 'frame_analyzed', payload: result });
                imageBitmap.close(); // Release memory
            }
        };
    </script>

    <script type="module">
        // --- DOM References ---
        const dom = {
            videoFilesInput: document.getElementById('video-files-input'),
            thresholdSlider: document.getElementById('threshold-slider'),
            thresholdValueEl: document.getElementById('threshold-value'),
            analyzeButton: document.getElementById('analyze-button'),
            cancelButton: document.getElementById('cancel-button'),
            loadingIndicator: document.getElementById('loading-indicator'),
            progressText: document.getElementById('progress-text'),
            progressBar: document.getElementById('progress-bar'),
            modelStatus: document.getElementById('model-status'),
            resultsListContainer: document.getElementById('results-list-container'),
            resultsListPlaceholder: document.getElementById('results-list-placeholder'),
            paginationControls: document.getElementById('pagination-controls'),
            detailsSection: document.getElementById('details-section'),
            detailsTitle: document.getElementById('details-title'),
            detailChartCanvas: document.getElementById('detail-chart'),
            logContainer: document.getElementById('log-container'),
            chartTooltip: document.getElementById('chart-tooltip'),
            keyFramesContainer: document.getElementById('key-frames-container'),
            keyFramesPlaceholder: document.getElementById('key-frames-placeholder'),
            howItWorksButton: document.getElementById('how-it-works-button'),
            howItWorksModal: document.getElementById('how-it-works-modal'),
            closeModalButton: document.getElementById('close-modal-button'),
            processingVideo: document.getElementById('processing-video'),
            processingCanvas: document.getElementById('processing-canvas'),
        };

        // --- Global State ---
        const state = {
            videoFiles: [],
            modelsLoaded: false,
            allAnalysisData: [],
            detailChart: null,
            currentPage: 1,
            analysisWorker: null,
            isAnalyzing: false,
            cancelRequested: false,
        };
        const ITEMS_PER_PAGE = 20;

        // --- GitHub API State ---
        const GITHUB_CONFIG = {
            owner: 'garimto81',
            repo: 'frame',
            token: '#{GITHUB_TOKEN_PLACEHOLDER}#',
            resultsIndexFile: 'data/results.json',
            assetsPath: 'data/assets'
        };
        const GITHUB_API_URL = `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/`;
        const GITHUB_HEADERS = { 'Authorization': `token ${GITHUB_CONFIG.token}`, 'Accept': 'application/vnd.github.v3+json' };

        // --- GitHub API Functions ---
        async function getFileFromGitHub(path) {
            try {
                const response = await fetch(GITHUB_API_URL + path, { headers: GITHUB_HEADERS });
                if (response.status === 404) return null;
                if (!response.ok) throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                return await response.json();
            } catch (error) {
                console.error(`GitHub Read Error: ${path}`, error);
                return 'error';
            }
        }
        
        async function uploadFileToGitHub(path, content, isBinary = false) {
             const body = {
                message: `Upload asset: ${path}`,
                content: isBinary ? content.split(',')[1] : btoa(unescape(encodeURIComponent(content)))
            };
            try {
                const response = await fetch(GITHUB_API_URL + path, {
                    method: 'PUT',
                    headers: GITHUB_HEADERS,
                    body: JSON.stringify(body)
                });
                if (!response.ok) throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                const result = await response.json();
                return result.content.download_url;
            } catch (error) {
                console.error(`GitHub Upload Error: ${path}`, error);
                return null;
            }
        }

        async function updateFileOnGitHub(path, content, sha, commitMessage) {
            const body = {
                message: commitMessage,
                content: btoa(unescape(encodeURIComponent(content))),
            };
            if (sha) {
                body.sha = sha;
            }
            
            try {
                const response = await fetch(GITHUB_API_URL + path, {
                    method: 'PUT',
                    headers: GITHUB_HEADERS,
                    body: JSON.stringify(body)
                });
                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`GitHub API Error: ${response.status} ${response.statusText} - ${errorBody.message}`);
                }
            } catch (error) {
                console.error(`GitHub Update Error: ${path}`, error);
                throw error;
            }
        }
        
        // --- UI & Render Functions ---
        function updateAnalyzeButtonState() {
            dom.analyzeButton.disabled = state.videoFiles.length === 0 || !state.modelsLoaded || state.isAnalyzing;
        }

        function toggleAnalysisControls(isAnalyzing) {
            state.isAnalyzing = isAnalyzing;
            state.cancelRequested = false;
            dom.loadingIndicator.classList.toggle('hidden', !isAnalyzing);
            dom.analyzeButton.classList.toggle('hidden', isAnalyzing);
            dom.cancelButton.classList.toggle('hidden', !isAnalyzing);
            dom.videoFilesInput.disabled = isAnalyzing;
            dom.thresholdSlider.disabled = isAnalyzing;
            updateAnalyzeButtonState();
        }

        function appendLog(message, colorClass) {
            if (dom.logContainer.querySelector('#log-placeholder')) {
                dom.logContainer.innerHTML = '';
            }
            const logEntry = document.createElement('div');
            logEntry.textContent = message;
            if (colorClass) logEntry.className = colorClass;
            dom.logContainer.appendChild(logEntry);
            dom.logContainer.scrollTop = dom.logContainer.scrollHeight;
        }

        function renderAnalysisResultsList() {
            dom.resultsListPlaceholder.classList.add('hidden');
            dom.resultsListContainer.innerHTML = '';
            if (state.allAnalysisData.length === 0) {
                 dom.resultsListPlaceholder.textContent = '저장된 분석 기록이 없습니다.';
                 dom.resultsListPlaceholder.classList.remove('hidden');
                 return;
            }

            const totalPages = Math.ceil(state.allAnalysisData.length / ITEMS_PER_PAGE);
            const startIndex = (state.currentPage - 1) * ITEMS_PER_PAGE;
            const paginatedData = state.allAnalysisData.slice(startIndex, startIndex + ITEMS_PER_PAGE);

            paginatedData.forEach((data) => {
                const item = document.createElement('div');
                item.className = 'result-item p-3 border-b flex justify-between items-center cursor-pointer';
                item.dataset.analysisId = data.analysisId;
                item.innerHTML = `
                    <div class="flex-grow">
                        <p class="font-medium text-gray-800 truncate text-sm">${data.fileName}</p>
                        <p class="text-xs text-gray-500">${new Date(data.timestamp).toLocaleString()}</p>
                    </div>
                    <div class="text-sm font-semibold ${data.problematic ? 'text-red-500' : 'text-green-600'}">
                        Avg: ${data.avgScore.toFixed(2)}
                    </div>`;
                dom.resultsListContainer.appendChild(item);
            });

            dom.resultsListContainer.querySelectorAll('.result-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    dom.resultsListContainer.querySelectorAll('.result-item').forEach(r => r.classList.remove('selected'));
                    item.classList.add('selected');
                    const analysisId = e.currentTarget.dataset.analysisId;
                    renderDetailedView(analysisId);
                    dom.detailsSection.scrollIntoView({ behavior: 'smooth' });
                });
            });
            renderPagination(totalPages);
        }

        function renderPagination(totalPages) {
            dom.paginationControls.innerHTML = '';
            if (totalPages <= 1) return;
            for (let i = 1; i <= totalPages; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.className = `px-3 py-1 rounded-md text-sm ${i === state.currentPage ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`;
                button.onclick = () => { state.currentPage = i; renderAnalysisResultsList(); };
                dom.paginationControls.appendChild(button);
            }
        }

        async function renderDetailedView(analysisId) {
            dom.detailsSection.classList.remove('hidden');
            dom.logContainer.innerHTML = '<p class="text-gray-400 text-center py-4">로그를 불러오는 중...</p>';
            
            const resultData = state.allAnalysisData.find(d => d.analysisId === analysisId);
            if (!resultData) return;
            dom.detailsTitle.textContent = `상세 분석: ${resultData.fileName}`;

            renderDetailChart(resultData);
            renderKeyFramesForDetail(resultData);

            try {
                const logFile = await getFileFromGitHub(`${GITHUB_CONFIG.assetsPath}/${analysisId}/log.txt`);
                if (logFile && logFile.content) {
                    const logContent = decodeURIComponent(escape(atob(logFile.content)));
                    dom.logContainer.innerHTML = '';
                    logContent.split('\n').forEach(line => {
                        const logEntry = document.createElement('div');
                        logEntry.textContent = line;
                        if(line.includes('흐림')) logEntry.className = 'text-red-500';
                        else if(line.includes('선명')) logEntry.className = 'text-green-500';
                        else if(line.startsWith('[START]')) logEntry.className = 'text-cyan-400';
                        else logEntry.className = 'text-gray-400';
                        dom.logContainer.appendChild(logEntry);
                    });
                } else {
                    throw new Error("Log file content is empty.");
                }
            } catch(e) {
                dom.logContainer.innerHTML = '<p class="text-gray-400 text-center py-4">저장된 로그 파일을 찾을 수 없습니다.</p>';
            }
        }
        
        function renderDetailChart(resultData) {
            if (state.detailChart) { state.detailChart.destroy(); }
            dom.detailChartCanvas.dataset.analysisId = resultData.analysisId;
            
            const blurryPoints = (resultData.keyFrames || []).filter(kf => kf.manualOverride !== 'ok').map(kf => ({x: kf.time, y: resultData.frameScores.find(fs => fs.time === kf.time)?.score || 0}));
            const okPoints = (resultData.keyFrames || []).filter(kf => kf.manualOverride === 'ok').map(kf => ({x: kf.time, y: resultData.frameScores.find(fs => fs.time === kf.time)?.score || 0}));

            state.detailChart = new Chart(dom.detailChartCanvas, {
                type: 'line',
                data: {
                    datasets: [
                        { label: '선명도', data: resultData.frameScores.map(fs => ({x: fs.time, y: fs.score})), borderColor: 'rgba(59, 130, 246, 0.5)', borderWidth: 1, pointRadius: 0, tension: 0.4, },
                        { label: '흐림 감지', data: blurryPoints, backgroundColor: 'rgb(239, 68, 68)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter', },
                        { label: '수동 확인', data: okPoints, backgroundColor: 'rgb(34, 197, 94)', pointRadius: 5, pointHoverRadius: 7, type: 'scatter', }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, interaction: { intersect: false, mode: 'index' },
                    plugins: { legend: { display: false }, tooltip: { enabled: false, external: createChartTooltip, position: 'nearest' } },
                    scales: { x: { type: 'linear', title: { display: true, text: '시간 (초)' } }, y: { beginAtZero: true, title: { display: true, text: '점수' } } }
                }
            });
        }
        
        function renderKeyFramesForDetail(resultData) {
            dom.keyFramesPlaceholder.classList.add('hidden');
            dom.keyFramesContainer.innerHTML = '';
            
            if (!resultData.keyFrames || resultData.keyFrames.length === 0) {
                dom.keyFramesPlaceholder.textContent = '이 분석에는 감지된 문제 프레임이 없습니다.';
                dom.keyFramesPlaceholder.classList.remove('hidden');
                return;
            }

            resultData.keyFrames.forEach(data => {
                const isOverridden = data.manualOverride === 'ok';
                const pairContainer = document.createElement('div');
                pairContainer.className = 'p-3 bg-white rounded-lg shadow-md border';
                pairContainer.innerHTML = `
                    <h4 class="font-bold text-md mb-2">@ ${data.time.toFixed(2)}초</h4>
                    <div class="flex gap-4 mb-2">
                        <div class="flex-1 text-center"><p class="text-sm font-semibold text-green-600 mb-1">선명</p><img src="${data.sharpUrl}" class="w-full rounded-md border" loading="lazy"></div>
                        <div class="flex-1 text-center"><p class="text-sm font-semibold ${isOverridden ? 'text-green-600' : 'text-red-600'} mb-1">${isOverridden ? '흐림 (수동OK)' : '흐림'}</p><img src="${data.blurryUrl}" class="w-full rounded-md border" loading="lazy"></div>
                    </div>
                    <button data-analysis-id="${resultData.analysisId}" data-time="${data.time}" class="manual-override-button w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm ${isOverridden ? 'hidden' : ''}">이 프레임은 문제 없음 (녹색으로 변경)</button>`;
                dom.keyFramesContainer.appendChild(pairContainer);
            });

            dom.keyFramesContainer.querySelectorAll('.manual-override-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const { analysisId, time } = e.currentTarget.dataset;
                    handleManualCorrection(analysisId, parseFloat(time));
                });
            });
        }
        
        function createChartTooltip(context) {
            const {chart, tooltip} = context;
            if (tooltip.opacity === 0) { dom.chartTooltip.style.opacity = 0; dom.chartTooltip.classList.add('hidden'); return; }
            
            const analysisId = chart.canvas.dataset.analysisId;
            const analysisData = state.allAnalysisData.find(d => d.analysisId === analysisId);
            const dataPoint = tooltip.dataPoints[0];
            const keyFrameData = analysisData.keyFrames.find(kf => kf.time === dataPoint.parsed.x);

            if (keyFrameData) {
                const isOverridden = keyFrameData.manualOverride === 'ok';
                dom.chartTooltip.innerHTML = `<div class="flex gap-4 p-1"><div class="text-center w-1/2"><p class="text-sm font-semibold text-green-400 mb-1">선명</p><img src="${keyFrameData.sharpUrl}" class="w-full h-auto object-contain rounded"></div><div class="text-center w-1/2"><p class="text-sm font-semibold ${isOverridden ? 'text-green-400' : 'text-red-400'} mb-1">${isOverridden ? '흐림 (수동OK)' : '흐림'}</p><img src="${keyFrameData.blurryUrl}" class="w-full h-auto object-contain rounded"></div></div>`;
                
                dom.chartTooltip.style.opacity = 1;
                dom.chartTooltip.classList.remove('hidden');
                
                const { offsetLeft, offsetTop } = chart.canvas;
                const tooltipX = offsetLeft + tooltip.caretX;
                const tooltipY = offsetTop + tooltip.caretY;
                
                dom.chartTooltip.style.left = `${tooltipX}px`;
                dom.chartTooltip.style.top = `${tooltipY}px`;
            } else { dom.chartTooltip.style.opacity = 0; dom.chartTooltip.classList.add('hidden'); }
        }

        // --- Core Logic ---
        async function initializeAndLoadGitHubData() {
            dom.resultsListPlaceholder.textContent = 'GitHub에서 분석 기록을 확인합니다...';
            try {
                let resultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);

                if (resultsFile === 'error') { throw new Error('GitHub 저장소 접근에 실패했습니다.'); }
                
                if (resultsFile === null) { 
                    console.log('results.json not found. Creating a new one.');
                    await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, '[]', null, 'Initialize results.json');
                    resultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
                }
                
                if(resultsFile && resultsFile.content) {
                    const content = decodeURIComponent(escape(atob(resultsFile.content)));
                    state.allAnalysisData = JSON.parse(content).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                } else {
                    state.allAnalysisData = [];
                }
            } catch(error) {
                console.error("Error initializing data:", error);
                dom.resultsListPlaceholder.textContent = `오류: ${error.message}`;
            } finally {
                renderAnalysisResultsList();
            }
        }

        async function handleManualCorrection(analysisId, time) {
            const analysisIndex = state.allAnalysisData.findIndex(d => d.analysisId === analysisId);
            if (analysisIndex === -1) return;
            const keyFrameIndex = state.allAnalysisData[analysisIndex].keyFrames.findIndex(kf => kf.time === time);
            if (keyFrameIndex === -1) return;

            state.allAnalysisData[analysisIndex].keyFrames[keyFrameIndex].manualOverride = 'ok';
            renderDetailedView(analysisId);

            try {
                const existingResultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
                if(!existingResultsFile) throw new Error("Could not fetch existing results file for manual override.");
                await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, JSON.stringify(state.allAnalysisData, null, 2), existingResultsFile.sha, `Update manual override for ${analysisId}`);
                alert("수동 재정의가 저장되었습니다.");
            } catch(error) {
                console.error(error);
                alert("수동 재정의 저장에 실패했습니다.");
                state.allAnalysisData[analysisIndex].keyFrames[keyFrameIndex].manualOverride = undefined;
                renderDetailedView(analysisId);
            }
        }
        
        async function startAnalysis() {
            if (state.isAnalyzing) return;
            if (state.videoFiles.length === 0) {
                alert('먼저 분석할 영상 파일을 선택해주세요.');
                return;
            }
            toggleAnalysisControls(true);
            dom.logContainer.innerHTML = '';
            dom.detailsSection.classList.add('hidden');
            
            const newAnalyses = [];

            for (let i = 0; i < state.videoFiles.length; i++) {
                if (state.cancelRequested) break;
                const file = state.videoFiles[i];
                const analysisResult = await processVideoFile(file, i, state.videoFiles.length);
                if (analysisResult) {
                    newAnalyses.push(analysisResult);
                }
            }

            if (newAnalyses.length > 0 && !state.cancelRequested) {
                 await finalizeAnalysis(newAnalyses);
            }
            
            if (state.cancelRequested) {
                appendLog('> [CANCEL] 사용자에 의해 분석이 중단되었습니다.', 'text-yellow-400');
            }

            toggleAnalysisControls(false);
        }

        async function processVideoFile(file, fileIndex, totalFiles) {
             const analysisId = `${file.name.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString()}`;
             appendLog(`> [START] '${file.name}' 분석 (ID: ${analysisId})`, 'text-cyan-400');
             dom.progressText.textContent = `[${fileIndex + 1}/${totalFiles}] '${file.name}' 분석 시작...`;

             const fileURL = URL.createObjectURL(file);
             dom.processingVideo.src = fileURL;

             const duration = await new Promise(resolve => {
                 dom.processingVideo.onloadedmetadata = () => resolve(dom.processingVideo.duration);
             });
             
             const threshold = parseFloat(dom.thresholdSlider.value);
             const SAMPLING_INTERVAL_SECONDS = 0.5;
             const totalSamples = Math.floor(duration / SAMPLING_INTERVAL_SECONDS);
             const frameResults = [];
             let liveLogContent = `[START] '${file.name}' 분석을 시작합니다. (ID: ${analysisId})\n`;
             const processingCtx = dom.processingCanvas.getContext('2d');
             
             for (let j = 0; j < totalSamples; j++) {
                 if (state.cancelRequested) break;
                 
                 const currentTime = j * SAMPLING_INTERVAL_SECONDS;
                 dom.progressText.textContent = `[${fileIndex + 1}/${totalFiles}] '${file.name}' 샘플링 ${j + 1}/${totalSamples}`;
                 dom.progressBar.value = (j / totalSamples) * 100;
                 
                 dom.processingVideo.currentTime = currentTime;
                 await new Promise(resolve => dom.processingVideo.onseeked = resolve);

                 dom.processingCanvas.width = dom.processingVideo.videoWidth;
                 dom.processingCanvas.height = dom.processingVideo.videoHeight;
                 processingCtx.drawImage(dom.processingVideo, 0, 0);
                 
                 const imageBitmap = await createImageBitmap(dom.processingCanvas);
                 
                 await new Promise(resolve => {
                     state.analysisWorker.onmessage = (event) => {
                         if (event.data.type === 'frame_analyzed') {
                             frameResults.push(event.data.payload);
                             resolve();
                         }
                     };
                     state.analysisWorker.postMessage({
                         type: 'analyze_frame',
                         payload: { imageBitmap, currentTime, threshold }
                     }, [imageBitmap]);
                 });
                 
                 const lastResult = frameResults[frameResults.length - 1];
                 const logLine = lastResult.faceFound 
                     ? `Time: ${lastResult.time.toFixed(2)}s | Score: ${lastResult.score.toFixed(2)} | Status: ${lastResult.isBlurry ? '흐림' : '선명'}`
                     : `Time: ${lastResult.time.toFixed(2)}s | Status: 얼굴 미검출`;
                 appendLog(logLine, lastResult.isBlurry ? 'text-red-500' : 'text-green-500');
                 liveLogContent += logLine + '\n';
             }
             
             URL.revokeObjectURL(fileURL);
             if (state.cancelRequested) return null;
             
             appendLog(`> [END] '${file.name}' 분석 완료.`);

             const keyFramesToUpload = [];
             for(let k = 1; k < frameResults.length; k++) {
                 const prev = frameResults[k-1];
                 const curr = frameResults[k];
                 if (prev.faceFound && curr.faceFound && !prev.isBlurry && curr.isBlurry) {
                     keyFramesToUpload.push({ time: curr.time, sharpDataURL: prev.dataURL, blurryDataURL: curr.dataURL });
                 }
             }
             
             const detectedFrameCount = frameResults.filter(r => r.faceFound).length;
             const totalScore = frameResults.reduce((sum, r) => sum + (r.score || 0), 0);
             const blurryFrameCount = frameResults.filter(r => r.isBlurry).length;
             const blurryPercentage = detectedFrameCount > 0 ? (blurryFrameCount / detectedFrameCount) * 100 : 0;

             return {
                analysisId,
                timestamp: new Date().toISOString(),
                fileName: file.name,
                avgScore: detectedFrameCount > 0 ? totalScore / detectedFrameCount : 0,
                problematic: blurryPercentage > 10,
                blurryPercentage,
                frameScores: frameResults.filter(r => r.faceFound).map(d => ({time: d.time, score: d.score})),
                keyFramesToUpload,
                logContent: liveLogContent,
            };
        }

        async function finalizeAnalysis(results) {
            dom.progressText.textContent = '분석 결과를 GitHub에 업로드 중...';
            dom.progressBar.value = 0;

            const newAnalyses = [];
            const totalUploads = results.reduce((sum, r) => sum + 1 + r.keyFramesToUpload.length, 0);
            let uploadsCompleted = 0;

            for(const result of results) {
                await uploadFileToGitHub(`${GITHUB_CONFIG.assetsPath}/${result.analysisId}/log.txt`, result.logContent, false);
                uploadsCompleted++;
                dom.progressBar.value = (uploadsCompleted / totalUploads) * 100;
                
                const uploadPromises = result.keyFramesToUpload.map(async (kf) => {
                    const cleanFileName = result.fileName.split('.').slice(0, -1).join('');
                    const sharpFileName = `${cleanFileName}_${kf.time.toFixed(2)}s_sharp.jpeg`;
                    const blurryFileName = `${cleanFileName}_${kf.time.toFixed(2)}s_blurry.jpeg`;

                    const sharpPromise = uploadFileToGitHub(`${GITHUB_CONFIG.assetsPath}/${result.analysisId}/${sharpFileName}`, kf.sharpDataURL, true);
                    const blurryPromise = uploadFileToGitHub(`${GITHUB_CONFIG.assetsPath}/${result.analysisId}/${blurryFileName}`, kf.blurryDataURL, true);

                    const [sharpUrl, blurryUrl] = await Promise.all([sharpPromise, blurryPromise]);
                    uploadsCompleted++;
                    dom.progressBar.value = (uploadsCompleted / totalUploads) * 100;

                    if (sharpUrl && blurryUrl) return { time: kf.time, sharpUrl, blurryUrl };
                    return null;
                });
                
                const uploadedKeyFrames = (await Promise.all(uploadPromises)).filter(Boolean);
                
                newAnalyses.push({
                    analysisId: result.analysisId, timestamp: result.timestamp, fileName: result.fileName,
                    avgScore: result.avgScore, problematic: result.problematic, blurryPercentage: result.blurryPercentage,
                    frameScores: result.frameScores, keyFrames: uploadedKeyFrames,
                });
            }
            
            dom.progressText.textContent = '최종 결과를 GitHub에 저장 중...';
            const existingResultsFile = await getFileFromGitHub(GITHUB_CONFIG.resultsIndexFile);
            let allResultsData = [];
            let currentSha = null;
            if (existingResultsFile && existingResultsFile.content) {
                allResultsData = JSON.parse(decodeURIComponent(escape(atob(existingResultsFile.content))));
                currentSha = existingResultsFile.sha;
            }
            
            allResultsData.unshift(...newAnalyses);
            
            await updateFileOnGitHub(GITHUB_CONFIG.resultsIndexFile, JSON.stringify(allResultsData, null, 2), currentSha, `Add analysis for ${newAnalyses.length} file(s)`);
            
            dom.videoFilesInput.value = '';
            state.videoFiles = [];
            await initializeAndLoadGitHubData();
            
            if (newAnalyses.length > 0) {
                 setTimeout(() => {
                    const firstNewItem = dom.resultsListContainer.querySelector(`[data-analysis-id="${newAnalyses[0].analysisId}"]`);
                    if(firstNewItem) firstNewItem.click();
                }, 100);
            }
        }
        
        function cancelAnalysis() {
            state.cancelRequested = true;
            dom.progressText.textContent = '분석을 중단하는 중...';
        }

        function setupModal() {
            const openModal = () => dom.howItWorksModal.classList.remove('hidden');
            const closeModal = () => dom.howItWorksModal.classList.add('hidden');

            dom.howItWorksButton.addEventListener('click', openModal);
            dom.closeModalButton.addEventListener('click', closeModal);
            dom.howItWorksModal.addEventListener('click', (e) => {
                if (e.target === dom.howItWorksModal) {
                    closeModal();
                }
            });
        }
        
        function setupWorker() {
            const workerScript = document.getElementById('analyzer-worker').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            state.analysisWorker = new Worker(URL.createObjectURL(workerBlob));
            
            return new Promise(resolve => {
                state.analysisWorker.onmessage = (event) => {
                     if (event.data.type === 'worker_ready') {
                        state.modelsLoaded = true;
                        dom.modelStatus.textContent = '얼굴 인식 모델 로딩 완료!';
                        updateAnalyzeButtonState();
                        resolve();
                    }
                };
                state.analysisWorker.postMessage({ type: 'init' });
            });
        }

        // --- Initializer ---
        async function initializeApp() {
            if (GITHUB_CONFIG.token.includes('PLACEHOLDER')) {
                dom.modelStatus.textContent = '오류: GitHub Actions를 통해 배포된 페이지에서 접속해야 합니다.';
                dom.analyzeButton.disabled = true;
                return;
            }
            dom.modelStatus.textContent = '페이지 및 모델 초기화 중...';
            setupModal();
            await setupWorker();
            await initializeAndLoadGitHubData();

            dom.videoFilesInput.addEventListener('change', (event) => {
                state.videoFiles = Array.from(event.target.files);
                updateAnalyzeButtonState();
            });
            dom.thresholdSlider.addEventListener('input', (event) => {
                dom.thresholdValueEl.textContent = event.target.value;
            });
            dom.analyzeButton.addEventListener('click', startAnalysis);
            dom.cancelButton.addEventListener('click', cancelAnalysis);
        }

        window.onload = initializeApp;

    </script>
</body>
</html>
